name: iOS CI/CD Pipeline

on:
  push:
    branches:
      - github-xcode-demo-2

jobs:
  build-and-deploy:
    runs-on: macos-latest

    concurrency:
      group: ${{ github.ref }}
      cancel-in-progress: true

    env:
      APP_IDENTIFIER: com.thinksys.habitTracker ##com.thinksys.covid
      APPLE_DEVELOPER_ACCOUNT: ${{ secrets.APPLE_DEVELOPER_ACCOUNT }}
      FASTLANE_APPLE_ID: ${{ secrets.FASTLANE_APPLE_ID }}
      TEAM_ID: ${{ secrets.TEAM_ID }}
      API_KEY_ID: ${{ secrets.FASTLANE_API_KEY_ID }}
      API_ISSUER_ID: ${{ secrets.FASTLANE_API_ISSUER_ID }}
      FASTLANE_PASSWORD: ${{ secrets.FASTLANE_PASSWORD }}
      FASTLANE_API_KEY_PATH: ${{ secrets.FASTLANE_API_KEY_PATH }}
      MATCH_PASSWORD: ${{ secrets.MATCH_PASSWORD }}
      ITC_TEAM_ID: ${{ secrets.ITC_TEAM_ID }}
      FASTLANE_API_KEY_KEY_ID: ${{ secrets.FASTLANE_API_KEY_KEY_ID }}
      FASTLANE_API_KEY_ISSUER_ID: ${{ secrets.FASTLANE_API_KEY_ISSUER_ID }}
      FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD: ${{ secrets.FASTLANE_APPLE_APPLICATION_SPECIFIC_PASSWORD }}

    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0

    - name: Set up Ruby
      uses: ruby/setup-ruby@v1
      with:
        ruby-version: '3.0'
        bundler-cache: true

    - name: Install dependencies
      run: |
        gem install bundler
        bundle install
        gem install fastlane
        gem install fastlane-plugin-versioning

    - name: Get Commit Message
      id: get_commit_message
      run: |
        COMMIT_MESSAGE=$(git log -1 --pretty=%B)
        echo "Commit message: $COMMIT_MESSAGE"
        echo "::set-output name=message::$COMMIT_MESSAGE"

    - name: Determine Version Type
      id: determine_version_type
      run: |
        COMMIT_MESSAGE="${{ steps.get_commit_message.outputs.message }}"
        if echo "$COMMIT_MESSAGE" | grep -qi "major"; then
          VERSION_TYPE="major"
        elif echo "$COMMIT_MESSAGE" | grep -qi "minor"; then
          VERSION_TYPE="minor"
        elif echo "$COMMIT_MESSAGE" | grep -qi "patch"; then
          VERSION_TYPE="patch"
        else
          echo "No version type found in the commit message."
          exit 1
        fi
        echo "Determined version type: $VERSION_TYPE"
        echo "::set-output name=version_type::$VERSION_TYPE"

    - name: Use Version Type
      run: |
        # VERSION_TYPE="${{ steps.determine_version_type.outputs.version_type }}"
        echo "VERSION_TYPE=${{ steps.determine_version_type.outputs.version_type }}" >> $GITHUB_ENV
        # echo "Proceeding with version type: $VERSION_TYPE"
        # echo "VERSION_TYPE=$VERSION_TYPE" >> $GITHUB_ENV

    - name: Debug Environment Variables
      run: env

    - name: Set up Apple Developer API Key
      run: |
        echo "The version type is: $VERSION_TYPE"
        echo '{
          "key_id": "${{ secrets.FASTLANE_API_KEY_KEY_ID }}",
          "issuer_id": "${{ secrets.FASTLANE_API_KEY_ISSUER_ID }}",
          "key_content": "${{ secrets.FASTLANE_API_KEY_P8 }}"
        }' > api_key.json
        echo "${{ secrets.FASTLANE_API_KEY_P8 }}" > api_key.p8

    - name: Configure AWS CLI
      env:
        AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
        AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        AWS_DEFAULT_REGION: ${{ secrets.AWS_DEFAULT_REGION }}
      run: |
        aws configure set aws_access_key_id $AWS_ACCESS_KEY_ID
        aws configure set aws_secret_access_key $AWS_SECRET_ACCESS_KEY
        aws configure set default.region $AWS_DEFAULT_REGION

    - name: Create and unlock keychain
      run: |
        security create-keychain -p ${{ secrets.KEYCHAIN_PASSWORD }} /Users/runner/Library/Keychains/ci-temp.keychain-db
        security unlock-keychain -p ${{ secrets.KEYCHAIN_PASSWORD }} /Users/runner/Library/Keychains/ci-temp.keychain-db
        security list-keychains -s /Users/runner/Library/Keychains/ci-temp.keychain-db
        security default-keychain -s /Users/runner/Library/Keychains/ci-temp.keychain-db
        security set-keychain-settings -t 3600 -l /Users/runner/Library/Keychains/ci-temp.keychain-db

    - name: Create Dynamic Fastlane Configuration
      run: |
        mkdir -p ./fastlane
        cat <<EOF > ./fastlane/Appfile
        apple_id("${{ secrets.FASTLANE_APPLE_ID }}")
        team_id("${{ secrets.TEAM_ID }}")
        itc_team_id("${{ secrets.ITC_TEAM_ID }}")
        app_identifier("${{ env.APP_IDENTIFIER }}")
        EOF

        cat <<EOF > ./fastlane/Matchfile
        s3_bucket("${{ secrets.S3_BUCKET_NAME }}")
        storage_mode("s3")
        type("appstore")
        app_identifier(["${{ env.APP_IDENTIFIER }}"])
        username("${{ secrets.FASTLANE_APPLE_ID }}")
        EOF

        cat <<EOF > ./fastlane/Fastfile
        default_platform(:ios)

        platform :ios do
          desc "Build and deploy to TestFlight"
          lane :beta do
            api_key = app_store_connect_api_key(
                key_id: "${{ secrets.FASTLANE_API_KEY_KEY_ID }}",
                issuer_id: "${{ secrets.FASTLANE_API_KEY_ISSUER_ID }}",
                key_content: "${{ secrets.FASTLANE_API_KEY_P8 }}"
            )
            version = get_app_store_version_number(bundle_id: "${{ env.APP_IDENTIFIER }}")
            puts "Checking AppStore version number set: #{version}"

            # If no version is returned, handle it
            if version.nil? || version.empty?
              UI.user_error!("Failed to fetch the latest version number from the App Store.")
            end

            # Get the version type from GitHub Actions input (patch, minor, or major)
            version_type = ENV["VERSION_TYPE"] || "patch"  # Default to patch if not provided

            # Split the version into major, minor, patch components
            major, minor, patch = version.split('.').map(&:to_i)

            # Increment the version based on the specified version type
            case version_type
            when "major"
              major += 1
            when "minor"
              minor += 1
            when "patch"
              patch += 1
            else
              UI.user_error!("Invalid version type provided.")
            end

            # Build the new version string
            new_version = "#{major}.#{minor}.#{patch}"
            #empty commit
            puts "New version after increment: #{new_version}"

            increment_version_number(
              version_number: new_version,
              xcodeproj: "Xcode Demo.xcodeproj"
            )

            # Fetch the latest build number from App Store Connect
            latest_build_number = nil
            begin
            latest_build_number = app_store_build_number(
              api_key: api_key,
              app_identifier: ENV['APP_IDENTIFIER'],
              live: false,
            )
             puts "Latest build number fetched from App Store: #{latest_build_number}"
           rescue => e
             puts "No existing build found, starting with build number 1"
           end

           # Determine the new build number
           new_build_number = (latest_build_number.nil? ? 1 : latest_build_number.to_i + 1)
           puts "New build number calculated: #{new_build_number}"
          
            # Update build number in Xcode project
            increment_build_number(
              build_number: new_build_number.to_s,
            )
            puts "New build number set: #{new_build_number}"

            # Use match for provisioning profiles and certificates
            match(
                type: "appstore",
                readonly: false,
                api_key: api_key,
                team_id: "${{ secrets.TEAM_ID }}",
                keychain_name: "ci-temp.keychain-db",
                keychain_password: "${{ secrets.KEYCHAIN_PASSWORD }}"
            )

            # Build the app
            build_app(
              scheme: "Xcode Demo",
              codesigning_identity: "Apple Distribution",
              export_options: {
                provisioningProfiles: {
                  "${{ env.APP_IDENTIFIER }}" => "match AppStore ${{ env.APP_IDENTIFIER }}"
                },
                marketingVersion: new_version
              },
              xcargs: "MARKETING_VERSION=#{new_version}"
            )

            # Upload to TestFlight
            upload_to_testflight(
              username: ENV['FASTLANE_APPLE_ID'],
              skip_waiting_for_build_processing: true,
              app_identifier: ENV['APP_IDENTIFIER'],
              app_version: new_version
            )
            
            # Delete temp keychain
            delete_keychain(name: "ci-temp.keychain")
          end
        end
        EOF

    - name: Build and Deploy to TestFlight
      env:
        # VERSION_TYPE: ${{ github.event.inputs.version_type }}
        VERSION_TYPE: ${{ steps.determine_version_type.outputs.version_type }}
      run: bundle exec fastlane ios beta

    - name: Notify Success
      if: success()
      run: echo "iOS Application successfully released to TestFlight."
